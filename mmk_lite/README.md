<h2>Соглашения о кодировании</h2>

<h3>Файлы и папки</h3>

- entity - чистые дата-объекты;
- dao - работа с удаленным и локальным хранилищами;
- model - вью-модели страниц пользовательского интерфейса, эмитируют экземпляры стейта;
- view - лишенные состояния виджеты пользовательского интерфейса;

Почему такие названия. В редакторе кода папки упорядочены по алфавиту, и последовательность dao - entity - model - view точно соответствует цепочке зависимостей для слоев архитектуры. Доменная логика не выделена в отдельный слой, считаем что для корпоративного фронтенда она в основном на сервере.

Если файл экспортирует один основной класс, то его имя совпадает с именем класса, например UserModel.dart. В противном случае используется стиль именования пакетов флаттера.

<h3>Имена</h3>

Все имена классов начинаются с имени бизнес-сущности, после которого идут различные суффиксы (в формате CamelCase):
- имя интерфейса заканчивается на Abstract;
- имя DAO-объекта содержит Dao, и оканчивается признаком конкретной реализации;
- имя виджета оканчивается названием роли в интерфейсе;

Например:
- UserAbstract - интерфейс объекта пользователя;
- User - конкретная реализация data-объекта пользователя;
- UserDaoAbstract - интерфейс DAO-объекта для доступа к хранилищу пользователей;
- UserDaoFirestore - конкретная реализация хранилища пользователей на базе FireStore;
- UserModel - view-model (контроллер) на базе Cubit, управляющая пользователем (пользователями);
- UserList - виджет списка пользователей;
- UserView - виджет просмотра информации о пользователе;
- UserEdit - виджет редактирования пользователя;

<h3>Объявление типов</h3>

Локальные переменные объявляются var с использованием инициирующих литералов, например:
<pre>
var notes = &lt;Note&gt;[];
</pre>

Сигнатуры функций всегда объявляются явно. Исключение - методы build(), createState(), замыкания builder, create, и т.д., которые можно записывать в сокращенной форме, полагаясь на автовывод и аннотацию @override, например:
<pre>
@override
build(context) {
    return Scaffold(...);
}
</pre>

<h3>Управление состоянием</h3>

Используется пакет flutter_bloc, модели на основе Cubit и Bloc. Если модель нужна нескольким экранам, она помещается выше по дереву (обычно все приложение оборачивается в MultiBlocProvider), если модель требуется только одному экрану - она создается непосредственно в методе build(). 

Абстрактный стейт - это обертка над данными, содержащая общие данные для управления виджетом.

Чтобы модель могла обратиться в другой модели, мы в каждую модель передаем context, и модели ищут предков через context.read<MyModelClass>().

Помните, что модель может эмитировать повторяющиеся идентичные стейты, виджет их принимает, но НЕ обновляет экран. Это полезное свойство, когда мы создаем формы ввода на основе stateless-виджетов.

<h3>Виджеты</h3>

Во всех случаях, когда это возможно, желательно использовать StatelessWidget, даже в формах ввода. Исключение - наличие контроллеров прокрутки, анимации, или когда локальное состояние уже имеется у дочернего виджета (например пакет flutter_map).

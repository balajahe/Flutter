<h2>Соглашения о кодировании</h2>

<h3>Файлы и папки</h3>

- /dao - Содержит интерфейсы и конкретные реализации классов для работы с локальными и сетевыми хранилищами.

- /model - Содержит чистые объекты данных (data object), модели с бизнес-логикой (model), и модели для экранов (view model).

- /view - Содержит виджеты экранов.

Если файл экспортирует один основной класс, то его имя совпадает с именем класса, например UserModel.dart. В противном случае используется стиль именования пакетов флаттера.

<h3>Имена</h3>

Все имена классов начинаются с имени бизнес-сущности, после которого идут различные суффиксы (в формате CamelCase):
- имя интерфейса заканчивается на Abstract;
- имя DAO-объекта содержит Dao, и оканчивается признаком конкретной реализации;
- имя виджета оканчивается названием роли в интерфейсе;
Например:
- UserAbstract - интерфейс объекта пользователя;
- User - конкретная реализация data-объекта пользователя;
- UserDaoAbstract - интерфейс DAO-объекта для доступа к хранилищу пользователей;
- UserDaoFireStore - конкретная реализация хранилища пользователей на базе FireStore;
- UserList - виджет списка пользователей;
- UserView - виджет просмотра информации о пользователе;
- UserEdit - виджет редактирования пользователя;

<h3>Объявление типов</h3>

Локальные переменные объявляются var с использованием инициирующих литералов, например:
<pre>
var notes = &lt;Note&gt;[];
</pre>

Сигнатуры функций всегда объявляются явно. Исключение - методы build(), createState(), замыкания builder, create, и т.д., которые можно записывать в сокращенной форме, полагаясь на автовывод и декларацию @override, например:
<pre>
@override
build(context) {
    return Scaffold(...);
}
</pre>

<h3>Управление состоянием</h3>

Используется пакет flutter_bloc, модели на основе Cubit и Bloc. Если модель нужна нескольким экранам, она помещается выше по дереву (обычно все приложение оборачивается в MultiBlocProvider), если модель требуется только одному экрану - она создается непосредственно в методе build(). Это кажется странным, но такой подход работает:

<pre>
class DefectAdd extends StatelessWidget {
  @override
  build(context) {
    var issueModel = context.read<IssueModel>();
    var defectModel = DefectModel();
    return BlocConsumer<DefectModel, Defect>(
      cubit: defectModel,
      builder: (context, state) {
        return Scaffold(...
</pre>

Здесь мы видим 2 модели - IssueModel мы получаем из контекста, а DefectModel создаем локально. При повторном открытии формы - данные первой модели останутся в памяти, а вторая модель будет очищена. Вторая модель НЕ очищается при повороте экрана и получении нового стейта, так как вызов build() мемоизируется для набора параметров конструктора виджета.

Помните, что модель может эмитировать повторяющиеся идентичные стейты, виджет их принимает, но НЕ обновляет экран. Это полезное свойство, когда мы создаем формы ввода данных на основе stateless-виджетов. Общая идея - когда нам нужно доставить в форму обновленный стейт (например после получения события onChange от поля ввода), мы эмитируем текущий объект состояния:
    emit(_current);
Если нам нужно дополнительно обновить форму, мы эмитируем клонированный стейт:
    emit(_current.clone());
Естественно, метод клонирования нужно реализовать в классей стейта (иногда это одновременно дата-объект), так как dart не предоставляет механизмов клонирования. Для целей обновления формы нам достаточно поверхностного клонирования, например для списков:
    emit(List.from(_current));
Глубоко клонированный стейт более безопасен, так как является иммутабельным объектом, и внутри виджета невозможно изменить глубокие уровни модели, кроме как через ее публичные методы (передача объектов по ссылке, увы, небезопасна).

При использовании Bloc (а не Cubit) желательно вместо классического способа добавления событий в Sink модели, создавать в самой модели соответствующие публичные функции. Это упрощает работу в редакторе кода, и не плодит лишних сущностей типа классов событий. Использование Bloc хоть и сложнее, но предпочтительней чем использование Cubit, так как в некоторых случаях поток входящих событий должен быть упорядочен, и обработку следующего события нельзя начинать пока не завершилась обработка предыдущего (Bloc это гарантирует, а Cubit нет).

<h3>Виджеты</h3>

Во всех случаях, когда это возможно, желательно использовать StatelessWidget, даже в формах ввода. Исключение - наличие контроллеров прокрутки, анимации, или когда локальное состояние уже имеется у дочернего виджета (например пакет flutter_map).

<h2>Соглашения о кодировании</h2>

<h3>Файлы и папки</h3>

- /dao - содержит чистые объекты данных (data object), а также интерфейсы и конкретные реализации объектов доступа к локальным и сетевым хранилищам;

- /model - содержит модели с бизнес-логикой, и модели для экранов (view model);

- /view - содержит виджеты экранов, и общие виджеты пользовательского интерфейса;

Если файл экспортирует один основной класс, то его имя совпадает с именем класса, например User.dart. В противном случае используется стиль именования пакетов флаттера.

<h3>Имена</h3>

Все имена классов начинаются с имени бизнес-сущности, после которого идут различные суффиксы (в формате CamelCase):
- имя интерфейса заканчивается на Abstract;
- имя DAO-объекта содержит Dao, и оканчивается признаком конкретной реализации;
- имя виджета оканчивается признаком роли в интерфейсе;

Например:
- UserAbstract - интерфейс объекта пользователя;
- User - конкретная реализация data-объекта пользователя;
- UserDaoAbstract - интерфейс DAO-объекта для доступа к хранилищу пользователей;
- UserDaoFireStore - конкретная реализация хранилища пользователей на базе FireStore;
- UserList - виджет списка пользователей;
- UserView - виджет просмотра информации о пользователе;
- UserEdit - виджет редактирования пользователя;

<h3>Объявление типов</h3>

Локальные переменные объявляются var с использованием инициирующих литералов, например:
var notes = <Note>[];

Сигнатуры функций всегда объявляются ясно. Исключение - методы build(), createState(), замыкания builder, create, и т.д., которые можно записывать в сокращенной форме, полагаясь на автовывод и декларацию @override, например:
@override
build(context) {
    ...
    return Scaffold(...);
}

<h3>Управление состоянием</h3>

Используется пакет flutter_bloc, модели Cubit и Bloc. При использовании Bloc желательно вместо классического способа добавления событий в Sink модели, создавать в самой модели соответствующие публичные функции. Это упрощает работу в редакторе кода, и не плодит лишних сущностей типа классов событий. Но при этом использование Bloc предпочтительней чем использование Cubit, так как в большинстве случаев поток входящих событий должен быть упорядочен, и обработку следующего события нежелательно начинать пока не завершилась обработка предыдущего (Bloc это гарантирует, а Cubit нет).

<h3>Виджеты</h3>

Во всех случаях когда это возможно необходимо использовать StatelessWidget, даже в формах ввода. Исключение - наличие контроллеров прокрутки, анимации, или когда локальное состояние есть у дочернего компонента (например пакет flutter_map).
Термины обсуждаемы, но сейчас структура папок такая:
- entity - чистые дата-объекты;
- dao - работа с удаленным и локальным хранилищами;
- model - вью-модели страниц пользовательского интерфейса, эмитируют экземпляры стейта;
- view - лишенные состояния виджеты пользовательского интерфейса;

Почему такие названия. В редакторе кода папки упорядочены по алфавиту, и последовательность dao - entity - model - view точно соответствует цепочке зависимостей для слоев архитектуры. Доменная модель не выделена, считаем что для корпоративного фронтенда она в основном на сервере.

Управление состоянием - модели на базе flutter_bloc (Cubit). Абстрактный стейт - это обертка над данными, содержащая общие для всех страниц флаги.

Управление сессией. В слое моделей своя сессия (SessionModel) где пока ничего не хранится кроме данных пользователя, в слое DAO своя сессия (SessionDao), в которой хранятся активные соединения с внешними системами. Остальные данные лежат в соответствующих моделях, смотри ContactModel. В dao-объектах стараемся данные не хранить, там только методы извлечения и сохранения.

Локальное хранилище - shared_preferences в сериализованном json. Не лучшее решение, зато работает на любом таргете - от веба до линукса.

Контакты загружаются через API лениво - по одному, по мере необходимости показа на экране, что конечно медленней чем загрузка диапазоном (API это позволяет), зато приложение получается более отзывчивым. Вопрос спорный - с одной стороны ленивая загрузка это плохо для клиентского поиска, с другой стороны скорость первого запуска иногда критична для маркетинга.

Сравнение локальных и удаленных данных производится на уровне модели, в классе ContactModel. Хранилище обновляется если не совпадает хэши, или если локальная копия не содержит контактов.

Обработка ошибок не реализована, поиск и сортировка контактов не реализованы, и так слишком много работы получилось.

PS
Код несовершенен, паттерны кривые, но как получилось. В версии 2.0 все будет по другому ))).

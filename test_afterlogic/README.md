Структура папок:
- entity - чистые дата-объекты;
- dao - работа с удаленным и локальным хранилищами;
- model - вью-модели страниц пользовательского интерфейса, эмитируют экземпляры стейта;
- view - лишенные состояния виджеты пользовательского интерфейса;

Почему такие названия. В редакторе кода папки упорядочены по алфавиту, и последовательность dao - entity - model - view точно соответствует цепочке зависимостей для слоев архитектуры. Доменная логика не выделена в отдельный слой, считаем что для корпоративного фронтенда она в основном на сервере.

Управление состоянием - модели на базе flutter_bloc (Cubit). Абстрактный стейт - это обертка над данными, содержащая общие данные для управления виджетом.

Управление сессией. В слое model своя сессия (SessionModel), где пока ничего не хранится кроме данных пользователя, в слое dao своя сессия (SessionDao), в которой хранятся активные соединения с внешними системами. Остальные данные лежат в соответствующих моделях (смотри ContactModel).

Локальное хранилище - shared_preferences, куда каждые N секунд сохраняется сериализованный JSON. Не лучшее решение, зато работает на любом таргете - от веба до линукса. Для теста пойдет.

Контакты загружаются через API лениво - по одному, по мере необходимости показа на экране, что конечно медленней чем загрузка диапазоном (API это позволяет), зато приложение получается более отзывчивым. Вопрос спорный - с одной стороны ленивая загрузка это плохо для клиентского поиска, с другой стороны скорость первого запуска иногда критична для маркетинга.

Сравнение локальных и удаленных данных производится на уровне модели, в классе ContactModel. Сравнение контактов идет через поиск в массиве. Можно хранить в Map, но не стал заморачиваться. Если прикрутить нормальную локальную СУБД, проблема отпадет.

Обработка ошибок не реализована, корректный разлогин не реализован, поиск и сортировка контактов не реализованы, и так много работы получилось.

PS
Код несовершенен, паттерны кривые, но как получилось. В версии 2.0 все будет по другому.
